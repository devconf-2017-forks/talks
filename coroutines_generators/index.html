<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Journey to the center of the asynchronous world</title>
  <meta name="author" content="Maciej Szulik">

  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/css/reveal.min.css"/>
  <style type="text/css">
    code{white-space: pre;}
    .reveal i{font-family: 'FontAwesome'; font-style: normal;}
    .side-by-side {box-sizing: border-box;display: flex;}
    .side-by-side .box {width: 50%;}
  </style>
  <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/css/theme/simple.css" id="theme">
  <link rel="stylesheet" media="print" href="http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/css/print/pdf.css" />
  <!--[if lt IE 9]>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/lib/js/html5shiv.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.2.0/css/font-awesome.min.css" />
  <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.2/styles/default.min.css" />
</head>
<body>
  <div class="reveal">
    <div class="slides">

      <section>
        <h1>Journey to the center of the asynchronous world</h1>
        <br />
        <h3>Maciej Szulik</h3>
        <p>Szczyrk, 2014</p>

        <aside class="notes">
          Since the release of Python 3.4 in March this year (2014-03-17), or
          I could even say, way before that date, one of the hottest and most frequently
          mentioned topics is the asynchronous processing introduced in asyncio module.
          This presentation on the other hand will NOT cover the module itself,
          but I'll try to show you some of the core concepts and inner workings
          of the asyncio module.
        </aside>
      </section>

      <section data-background="img/movie_poster.jpg">

        <aside class="notes">
          The story involves German professor Otto Lidenbrock who believes there
          are volcanic tubes going toward the centre of the Earth. He, his nephew Axel,
          and their guide Hans descend into the Icelandic volcano Snæfellsjökull,
          encountering many adventures, including prehistoric animals and natural
          hazards, before eventually coming to the surface again in southern Italy,
          at the Stromboli volcano.
        </aside>
      </section>

      <section>
        <h2>TOC</h2>
        <p>About me</p>
        <p>Generators</p>
        <p>Coroutines</p>
        <p>Context managers</p>
        <p><code>asyncio</code> basics</p>
        <p>Q &amp; A</p>
      </section>

      <section>
        <h2>About me</h2>
        <p>soltysh @ <i class="fa-twitter"></i>&nbsp;<i class="fa-github"></i>&nbsp;
          <i class="fa-bitbucket"></i>&nbsp;<i class="fa-google"></i></p>
        <p>Programming ~10 years</p>
        <p>C/C++, Java, JavaScript, Ruby, Bash, Go</p>
      </section>

      <section>
        <h3>But I <i class="fa-heart"></i> Python</h3>
        <img src="img/python.png" />
      </section>

      <section>
        <h3>and I work for</h3>
        <img src="img/redhat_openshift.png" />

        <aside class="notes">
          <p>~5 mins</p>
          <p>OpnShift supports multiple languages, right?</p>
        </aside>
      </section>

      <section>
        <pre><code class="python">
def countdown(n):
    while n > 0:
        yield n
        n -= 1
        </code></pre>
        <pre class="fragment"><code class="python">
for c in countdown(3):
    print(c)
        </code></pre>
        <pre class="fragment"><code class="python">
c = countdown(3)
next(c)
next(c)
next(c)
next(c) # throws StopIteration exception
        </code></pre>

        <aside class="notes">
          generator1.py
        </aside>
      </section>

      <section data-background="img/yield.jpg">
        <h3 class="fragment">
          <p>Iterator protocol - <a href="http://legacy.python.org/dev/peps/pep-0234/">PEP-234</a></p>
          <p>Generators - <code>yield</code> - <a href="http://legacy.python.org/dev/peps/pep-0255/">PEP-255</a></p>
        </h3>

        <aside class="notes">
          <p>An object can be iterated over with "for" if it implements __iter__() or __getitem__().
          And secondly an object can function as an iterator if it implements next().
          </p>

          <p>Proceed to the first yield expression, where it is suspended, returning the value.
            Suspended means here local state is retained (local variables, the instruction pointer,
            and the internal evaluation stack).
          </p>
          <p>Examples: list values on the fly, iterator replacement, infinite data streams</p>
        </aside>
      </section>

      <section>
        <pre><code class="python">
def receiver():
    while True:
        item = yield
        print("Got: ", item)
        </code></pre>
        <pre class="fragment"><code class="python">
c = receiver()    # create the generator
next(c)           # advance to yield
c.send(43)        # sending values to generator
c.send([1, 2, 3])
c.send("Hello")
        </code></pre>

        <aside class="notes">
          generator2.py
        </aside>
      </section>

      <section data-background="img/coroutines.png">
        <span class="fragment">
          <h2>Coroutines</h2>
          <h3>generators on steroids - <a href="http://legacy.python.org/dev/peps/pep-0342/">PEP-342</a></h3>
        </span>

        <aside class="notes">
          Coroutines are computer program components that allow multiple entry points for suspending
          and resuming execution at certain locations.
          What then needed to be done with Python is to extend current generator implementation with
          ability to send values into the generator. This in turn allows performing asynchronous
          operations without needing to write the entire application as a series of callbacks, and
          without requiring the use of resource-intensive threads for programs that need hundreds or
          even thousands of co-operatively multitasking pseudothreads.
        </aside>
      </section>

      <section>
        <h3>Coroutine methods</h3>
        <p><code>next()</code> - advance code to the <code>yield</code> and emit a value</p>
        <p><code>send()</code> - sends a value to the <code>yield</code>, making it produce a value</p>
        <p><code>close()</code> - inform the generator that it should finish its work</p>
        <p><code>throw()</code> - sends an error to generator</p>
      </section>

      <section>
        <pre><code class="python">
def yieldfrom(x, y):
    yield from x
    yield from y
        </code></pre>
        <pre class="fragment"><code class="python">
a = [1, 2, 3]
b = [4, 5, 6]
for i in yieldfrom(yieldfrom(a, b), yieldfrom(b, a)):
    print(i, ' ')
        </code></pre>

        <aside class="notes">
          <p>yieldfrom.py</p>
          <p>You can think of this as iterating over and doing yield on each value.
        </aside>
      </section>

      <section>
        <h3>Delegating to subgenerator (<a href="http://legacy.python.org/dev/peps/pep-0380/">PEP-380</a>)</h3>
        <img class="fragment" src="img/delegation.jpg" />

        <aside class="notes">
          Prior to this delegation there was no option to reuse code with generator inside other generator.
          That was changed in PEP-380 to allow factoring out these bits of code into separate functions.
          All this changes were made to simplify writing asynchronous code, so basically these are
          foundations for asyncio.
        </aside>
      </section>

      <section>
        <pre><code class="python">
def returnyield(x):
    yield x
    return "Hi there"
        </code></pre>
        <h3>
          <i class="fa-question"></i>&nbsp;<i class="fa-question"></i>&nbsp;<i class="fa-question"></i>&nbsp;
        </h3>

        <aside class="notes">
          <p>yieldfrom.py</p>
          <p>The before mentioned PEP-380 also introduced this enhancement, question: what does this
          piece of code return?</p>
          <p>Answer: the return statement is passed as value to the StopIteration exception.</p>
        </aside>
      </section>

      <section>
        <pre><code class="python">
file = open()
# do some stuff with file
file.close()
        </code></pre>
        <pre><code class="python">
lock.acquire()
# do some stuff with lock
lock.release()
        </code></pre>

        <aside class="notes">
          <p>~15 mins</p>
        </aside>
      </section>

      <section>
        <pre><code class="python">
file = open()
# do some stuff with file
file.close()
        </code></pre>
        <pre><code class="python">
class tempdir(object):

    def __enter__(self):
        self.dirname = tempfile.mkdtemp()
        return self.dirname

    def __exit__(self, exc, val, tb):
        shutil.rmtree(self.dirname)
        </code></pre>
      </section>

      <section>
        <pre><code class="python">
class tempdir(object):
    def __enter__(self):
        self.dirname = tempfile.mkdtemp()
        return self.dirname
    def __exit__(self, exc, val, tb):
        shutil.rmtree(self.dirname)
        </code></pre>
        <pre><code class="python">
with tempdir() as dirname:
    print(dirname, os.path.isdir(dirname))
        </code></pre>

        <aside class="notes">
          contextmanager2.py
        </aside>
      </section>

      <section>
        <h3>
          Context managers - <code>with</code> - <a href="http://legacy.python.org/dev/peps/pep-0343/">PEP-343</a>
        </h3>
        <img src="img/context_managers.jpg" />

        <aside class="notes">
          The idea is to simplify repetitive operations, that an be unified.
        </aside>
      </section>

      <section style="white-space: nowrap;">
        <h2>Context managers</h2>
        <p><code>__enter__()</code> - start work with your object, returning it</p>
        <p><code>__exit__()</code> - release the object, or handle the exception</p>
      </section>

      <section>
        <pre><code class="python">
class tempdir(object):
    def __enter__(self):
        self.dirname = tempfile.mkdtemp()
        return self.dirname
    def __exit__(self, exc, val, tb):
        shutil.rmtree(self.dirname)
        </code></pre>

        <aside class="notes">
          Although this piece of code is not that hard to write, but in a way it's cumbersome to write.
          Isn't there a better and simpler solution?
        </aside>
      </section>

      <section>
        <pre><code class="python">
<strike>class tempdir(object):</strike>
    <strike>def __enter__(self):</strike>
        self.dirname = tempfile.mkdtemp()
        <strike>return</strike> yield self.dirname
        </code></pre>
        <pre><code class="python">
    <strike>def __exit__(self, exc, val, tb):</strike>
        shutil.rmtree(self.dirname)
        </code></pre>
      </section>

      <section>
        <pre><code class="python">
@contextmanager
def tempdir():
    dirname = tempfile.mkdtemp()
    try:
        yield dirname
    finally:
        shutil.rmtree(dirname)
        </code></pre>

        <aside class="notes">
          contextmanager2.py
        </aside>
      </section>

      <section>
        <pre><code class="python">
def contextmanager(func):
    @wraps(func)
    def helper(*args, **kwds):
        return _GeneratorContextManager(func, *args, **kwds)
    return helper
        </code></pre>
        <pre><code class="python">
class _GeneratorContextManager(ContextDecorator):
    # ...
    def __enter__(self):
        try:
            return next(self.gen)
        except StopIteration:
            raise RuntimeError("generator didn't yield") from None

    def __exit__(self, type, value, traceback):
        if type is None:
            try:
                next(self.gen)
            except StopIteration:
                return
            else:
                raise RuntimeError("generator didn't stop")
        else:
            # ...
        </code></pre>

        <aside class="notes">
          This is part of the code from contextlib.py that's responsible for handling the decorator.
          The performance of the decorator is ~9% slower, but the gain in readability is much bigger.
        </aside>
      </section>

      <section data-background="img/async.png">
      </section>

      <section>
        <pre><code class="python">
def executor(x, y):
    time.sleep(10)
    return x + y
        </code></pre>
        <pre class="fragment"><code class="python">
pool = ThreadPoolExecutor(8)
fut = pool.submit(executor, 2, 3)
fut.result()
        </code></pre>

        <aside class="notes">
          <p>~30 mins</p>
          <p>Prior to asyncio when writing asynchronous code of any sort you'd write a super complicated
          function and put it into some sort of an executor, in our case we create ThreadPoolExecutor.
          Obviously we're using threads here, but you can easily exchange in with ProcessPoolExecutor.
        </aside>
      </section>

      <section>
        <pre><code class="python">
def executor(x, y):
    time.sleep(10)
    return x + y
        </code></pre>
        <pre><code class="python">
def handle_result(result):
    print("Got: ", result.result())
        </code></pre>
        <pre><code class="python">
pool = ThreadPoolExecutor(8)
fut = pool.submit(executor, 2, 3)
fut.add_done_callback(handle_result)
        </code></pre>

        <aside class="notes">
          What you can do more with that simple example is create a notification when our super
          complicated task is over. To do so you'd have to add some callback function.
        </aside>
      </section>

      <section>
        <pre><code class="python">
class Task:
    def __init__(self, gen):
        self._gen = gen

    def step(self, value=None):
        try:
            fut = self._gen.send(value)
            fut.add_done_callback(self._wakeup)
        except StopIteration as exc:
            pass

    def _wakeup(self, fut):
        result = fut.result()
        self.step(result)
        </code></pre>

        <aside class="notes">
          Let's then go one step further in our simplifications and write a class that will handle
          for us all the boilerplate we needed to write on the previous slide. Let's use it then.
        </aside>
      </section>

      <section>
        <pre><code class="python">
def recursive(pool, n):
    yield pool.submit(time.sleep, 0.001)
    print(n)
    Task(recursive(pool, n+1)).step()
        </code></pre>

        <aside class="notes">
          <p>task1.py</p>
          <p>Let's create some sort of weird, recursive function that will call ourself but beforehand
          it'll print the argument passed in.</p>
        </aside>
      </section>

      <section>
        <pre><code class="python">
class Task(Future):                     # <-----
    def __init__(self, gen):
        super().__init__()              # <-----
        self._gen = gen
    def step(self, value=None):
        try:
            fut = self._gen.send(value)
            fut.add_done_callback(self._wakeup)
        except StopIteration as exc:
            self.set_result(exc.value)  # <-----
    def _wakeup(self, fut):
        result = fut.result()
        self.step(result)
        </code></pre>
      </section>

      <section>
        <pre><code class="python">
def calc(x, y):
    print("I'm going to sleep for a while...")
    time.sleep(10)
    return x + y

def do_calc(pool, x, y):
    result = yield from pool.submit(calc, x, y)
    return result
        </code></pre>
        <pre class="fragment"><code class="python">
pool = ProcessPoolExecutor(8)
t = Task(do_calc(pool, 2, 3))
t.step()
print("Got ", t.result())
        </code></pre>

        <pre class="fragment"><code class="python">
def patch_future(cls):
    def __iter__(self):
        if not self.done():
            yield self
        return self.result()
    cls.__iter__ = __iter__
        </code></pre>

        <aside class="notes">
          <p>task2.py</p>
          <p>Future object is not iterable, so we'd have to somehow force it to be.</p>
        </aside>
      </section>

      <section>
        <pre><code class="python">
class Task(futures.Future):
    """A coroutine wrapped in a Future."""
        </code></pre>
        ...
        <pre><code class="python">
    def _step(self, value=None, exc=None):
        try:
            if exc is not None:
                result = coro.throw(exc)
            elif value is not None:
                result = coro.send(value)
            else:
                result = next(coro)
        except StopIteration as exc:
            self.set_result(exc.value)
        </code></pre>
        ...
        <pre><code class="python">
    def _wakeup(self, future):
        try:
            value = future.result()
        except Exception as exc:
            self._step(None, exc)
        </code></pre>

        <aside class="notes">
          asyncio/tasks.py file
        </aside>
      </section>

      <section>
        <div class="side-by-side">
          <div class="box">
            <h3>David Beazley</h3><br />
            <a href="http://www.dabeaz.com/generators/">Generator Tricks for Systems Programmers</a><br /><br />
            <a href="http://www.dabeaz.com/coroutines/">A Curious Course on Coroutines and Concurrency</a><br /><br />
            <a href="http://www.dabeaz.com/finalgenerator/">Generators: The Final Frontier</a><br /><br />
          </div>
          <div class="box">
            <img src="img/pythoncookbook.jpg" />
          </div>
        </div>
      </section>

      <section>
        <h1><i class="fa-question"></i>&nbsp;<i class="fa-question"></i>&nbsp;<i class="fa-question"></i></h1>
        <br /><br /><br /><br />
        <h3>Maciej Szulik</h3>
        <h3>soltysh @ <i class="fa-twitter"></i>&nbsp;<i class="fa-github"></i>&nbsp;
          <i class="fa-bitbucket"></i>&nbsp;<i class="fa-google"></i></h3>
      </section>

    </div>
  </div>

  <script src="http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/lib/js/head.min.js"></script>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/js/reveal.min.js"></script>

  <script>
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,
        theme: 'night',
        transition: 'none',
        dependencies: [
          { src: 'http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.2/highlight.min.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: '../plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
        ]
      });
    </script>
  </body>
</html>
